}
}
}
return(stability)
}
#and a test
stability_time(test, error_multiplyer = 1.5)
View(test)
pyramid_plot<- function(data, title="", significance=0.05, plot_insig=TRUE, rsq_points=FALSE, caption_plot=""){
#suggested change
colnames(data) <- c("year", "abundance")
################
out<-multiple_breakups(data)
years<-length(unique(out$start_year))
maxyears<-max(out$N_years)
out<-multiple_breakups(data)
count<-nrow(out)
#compute mean and sd of longest series for vertical lines
true_slope<-out[count,4] #find the slope of the longest series
#remember to convert standard error to standard deviation
true_error<-(out[count,5])*(sqrt(out[count, 2]))#find the error of the longest series
max_true<-true_slope+true_error #compute max and min values for slopes we are calling true
min_true<-true_slope-true_error
out$significance<-ifelse(out$p_value<significance, "YES", "NO")
if(rsq_points==TRUE){
point_scale<-10*out$r_square
yespt<-1
}else{
point_scale<-2
yespt<-16
}
if(plot_insig==FALSE){
out<-out[which(out$p_value<significance),]
}
plot<- ggplot(out) +
theme_classic() +
geom_hline(yintercept = true_slope, linetype = 2) +
geom_hline(yintercept = max_true, linetype = 3, color="grey") +
geom_hline(yintercept = min_true, linetype = 3, color="grey") +
aes(y = slope, x = N_years,  ymin = (slope-slope_se),
ymax = (slope+slope_se), shape=significance, color=significance) +
geom_linerange(show.legend = F)+
geom_point(size=point_scale)+ ggtitle(title)+
scale_shape_manual(values=c("NO"=4,"YES"=yespt))+
scale_color_manual(values=c("NO"="red","YES"="black"))+
xlab("Number of years in window")+
scale_x_continuous(lim=c(3, maxyears))+
labs(caption = caption_plot)+
theme(plot.title = element_text(size=22))+
theme(axis.title.x = element_text(size=17, face = "bold"))+
theme(axis.title.y = element_text(size=17, face = "bold"))+
theme(axis.text = element_text(size=14))+
theme(legend.text = element_text(size = 12))+
theme(legend.title = element_text(size = 14))+
theme(plot.caption = element_text(size = 14,hjust = 0.5,margin = margin(7,0,0,0,unit = "pt")))+
coord_flip()
return(plot)
}
pyramid_plot(test, title="test plot", plot_insig = TRUE, significance=0.05, rsq_points =TRUE, caption_plot = "hey")
#read in tick adult data
tick_adults_data <- read.csv("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/data/Deer_Tick_Surveillance__Adults__Oct_to_Dec__excluding_Powassan_virus__Beginning_2008.csv", head = T)
#create vector of counties in NY state in the dataset
counties <- unique(tick_adults_data$County)
counties <- na.omit(counties)
counties <- as.character(counties)
#set up vectors to collect results of stability time, absolute range, relative range
#run on adult deer tick data for each county with at least 10 years data
counties.with.10.years.data = c()
stability.time = c()
absolute.range.min.value = c()
absolute.range.max.value = c()
relative.range.min.value = c()
relative.range.max.value = c()
proportion.significant = c()
proportion.wrong = c()
for (i in counties) {
tryCatch({
#location: i
county <- tick_adults_data[tick_adults_data$County == i,]
#get only year and ticks found column
tick_adults <- county[,c("Year", "Tick.Population.Density")]
#omit nas
tick_adults <- na.omit(tick_adults)
#data now cleaned
#if number of years in location exceeds 9 run functions
if(nrow(tick_adults) >= 10) {
#i returns county name
print(i)
counties.with.10.years.data <- c(counties.with.10.years.data, i)
#iterates through our targetted windows and returns summary statistics
print("Multiple Breakups")
print(multiple_breakups(tick_adults))
#returns how many years it takes to reach stability
print("Stability Time")
st <- stability_time(tick_adults)
print(st)
stability.time <- c(stability.time, st)
#abs_range returns the absolute range of significant findings
print("Absolute Range")
ar <- abs_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(ar)
absolute.range.min.value <- c(absolute.range.min.value, ar[1])
absolute.range.max.value <- c(absolute.range.max.value, ar[2])
#relative_range returns the absolute over and under estimate compared to the slope of the longest series
print("Relative Range")
rr <- relative_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(rr)
relative.range.min.value <- c(relative.range.min.value, rr[1])
relative.range.max.value <- c(relative.range.max.value, rr[2])
#returns the proportion of total windows with statistically significant values
print("Proportion Significant")
ps <- proportion_significant(tick_adults, significance = 0.05)
proportion.significant <- c(proportion.significant, ps)
#proportion of significant relationships that does not match the direction of the true slope
print("Proportion Significantly Wrong")
psw <- proportion_wrong(tick_adults, significance = 0.05)
proportion.wrong <- c(proportion.wrong, psw)
#print pyramid plot to png
png(filename = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/Adult deer tick density in ", i, ", NY ",Sys.Date(),".png", sep = ''), width = 876, height = 604)
print(pyramid_plot(tick_adults, title=paste("Adult deer tick density in ", i, ", NY", sep = ''), plot_insig = TRUE, significance=0.05, rsq_points =TRUE, caption_plot = paste("Stability Time:", st)))
dev.off()
}
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
county_adult_tick_data_results <- data.frame(counties.with.10.years.data, stability.time, absolute.range.min.value, absolute.range.max.value, relative.range.min.value, relative.range.max.value)
write.csv(county_adult_tick_data_results, file = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/ny_county_adult_tick_data_results_",Sys.Date(),".csv",sep = ""))
#read in tick adult data
tick_adults_data <- read.csv("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/data/Deer_Tick_Surveillance__Adults__Oct_to_Dec__excluding_Powassan_virus__Beginning_2008.csv", head = T)
#create vector of counties in NY state in the dataset
counties <- unique(tick_adults_data$County)
counties <- na.omit(counties)
counties <- as.character(counties)
#set up vectors to collect results of stability time, absolute range, relative range
#run on adult deer tick data for each county with at least 10 years data
counties.with.10.years.data = c()
stability.time = c()
absolute.range.min.value = c()
absolute.range.max.value = c()
relative.range.min.value = c()
relative.range.max.value = c()
proportion.significant = c()
proportion.wrong = c()
for (i in counties) {
tryCatch({
#location: i
county <- tick_adults_data[tick_adults_data$County == i,]
#get only year and ticks found column
tick_adults <- county[,c("Year", "Tick.Population.Density")]
#omit nas
tick_adults <- na.omit(tick_adults)
#data now cleaned
#if number of years in location exceeds 9 run functions
if(nrow(tick_adults) >= 10) {
#i returns county name
print(i)
counties.with.10.years.data <- c(counties.with.10.years.data, i)
#iterates through our targetted windows and returns summary statistics
print("Multiple Breakups")
print(multiple_breakups(tick_adults))
#returns how many years it takes to reach stability
print("Stability Time")
st <- stability_time(tick_adults)
print(st)
stability.time <- c(stability.time, st)
#abs_range returns the absolute range of significant findings
print("Absolute Range")
ar <- abs_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(ar)
absolute.range.min.value <- c(absolute.range.min.value, ar[1])
absolute.range.max.value <- c(absolute.range.max.value, ar[2])
#relative_range returns the absolute over and under estimate compared to the slope of the longest series
print("Relative Range")
rr <- relative_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(rr)
relative.range.min.value <- c(relative.range.min.value, rr[1])
relative.range.max.value <- c(relative.range.max.value, rr[2])
#returns the proportion of total windows with statistically significant values
print("Proportion Significant")
ps <- proportion_significant(tick_adults, significance = 0.05)
print(ps)
proportion.significant <- c(proportion.significant, ps)
#proportion of significant relationships that does not match the direction of the true slope
print("Proportion Significantly Wrong")
psw <- proportion_wrong(tick_adults, significance = 0.05)
print(psw)
proportion.wrong <- c(proportion.wrong, psw)
#print pyramid plot to png
png(filename = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/Adult deer tick density in ", i, ", NY ",Sys.Date(),".png", sep = ''), width = 876, height = 604)
print(pyramid_plot(tick_adults, title=paste("Adult deer tick density in ", i, ", NY", sep = ''), plot_insig = TRUE, significance=0.05, rsq_points =TRUE, caption_plot = paste("Stability Time:", st)))
dev.off()
}
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
county_adult_tick_data_results <- data.frame(counties.with.10.years.data, stability.time, absolute.range.min.value, absolute.range.max.value, relative.range.min.value, relative.range.max.value, proportion.significant, proportion.wrong)
write.csv(county_adult_tick_data_results, file = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/ny_county_adult_tick_data_results_",Sys.Date(),".csv",sep = ""))
#read in tick adult data
tick_adults_data <- read.csv("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/data/Deer_Tick_Surveillance__Adults__Oct_to_Dec__excluding_Powassan_virus__Beginning_2008.csv", head = T)
#create vector of counties in NY state in the dataset
counties <- unique(tick_adults_data$County)
counties <- na.omit(counties)
counties <- as.character(counties)
#set up vectors to collect results of stability time, absolute range, relative range
#run on adult deer tick data for each county with at least 10 years data
counties.with.10.years.data = c()
stability.time = c()
absolute.range.min.value = c()
absolute.range.max.value = c()
relative.range.min.value = c()
relative.range.max.value = c()
proportion.significant = c()
proportion.wrong = c()
for (i in counties) {
tryCatch({
#location: i
county <- tick_adults_data[tick_adults_data$County == i,]
#get only year and ticks found column
tick_adults <- county[,c("Year", "Tick.Population.Density")]
#omit nas
tick_adults <- na.omit(tick_adults)
#data now cleaned
#if number of years in location exceeds 9 run functions
if(nrow(tick_adults) >= 10) {
#i returns county name
print(i)
counties.with.10.years.data <- c(counties.with.10.years.data, i)
#iterates through our targetted windows and returns summary statistics
print("Multiple Breakups")
print(multiple_breakups(tick_adults))
#returns how many years it takes to reach stability
print("Stability Time")
st <- stability_time(tick_adults)
print(st)
stability.time <- c(stability.time, st)
#abs_range returns the absolute range of significant findings
print("Absolute Range")
ar <- abs_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(ar)
absolute.range.min.value <- c(absolute.range.min.value, ar[1])
absolute.range.max.value <- c(absolute.range.max.value, ar[2])
#relative_range returns the absolute over and under estimate compared to the slope of the longest series
print("Relative Range")
rr <- relative_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(rr)
relative.range.min.value <- c(relative.range.min.value, rr[1])
relative.range.max.value <- c(relative.range.max.value, rr[2])
#returns the proportion of total windows with statistically significant values
print("Proportion Significant")
ps <- proportion_significant(tick_adults, significance = 0.05)
print(ps)
proportion.significant <- c(proportion.significant, ps)
#proportion of significant relationships that does not match the direction of the true slope
print("Proportion Significantly Wrong")
psw <- proportion_wrong(tick_adults, significance = 0.05)
print(psw)
proportion.wrong <- c(proportion.wrong, psw)
#print pyramid plot to png
png(filename = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/Adult deer tick density in ", i, ", NY ",Sys.Date(),".png", sep = ''), width = 876, height = 604)
print(pyramid_plot(tick_adults, title=paste("Adult deer tick density in ", i, ", NY", sep = ''), plot_insig = TRUE, significance=0.05, rsq_points =TRUE, caption_plot = paste("Stability Time:", st)))
dev.off()
}
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
county_adult_tick_data_results <- data.frame(counties.with.10.years.data, stability.time, absolute.range.min.value, absolute.range.max.value, relative.range.min.value, relative.range.max.value)#, proportion.significant, proportion.wrong)
write.csv(county_adult_tick_data_results, file = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/ny_county_adult_tick_data_results_",Sys.Date(),".csv",sep = ""))
proportion.wrong
proportion.significant
counties
counties.with.10.years.data
county_adult_tick_data_results <- data.frame(counties.with.10.years.data, stability.time, absolute.range.min.value, absolute.range.max.value, relative.range.min.value, relative.range.max.value)#, proportion.significant, proportion.wrong)
View(county_adult_tick_data_results)
county_adult_tick_data_results <- data.frame(counties.with.10.years.data, stability.time, absolute.range.min.value, absolute.range.max.value, relative.range.min.value, relative.range.max.value, proportion.significant, proportion.wrong)
proportion_wrong(test, significance=0.01)
#call to bad breakup algorithm developed by Dr. Christie Bahlai of Kent State
source("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/bad_breakup_2/R_model/bad_breakup_script.R")
#-------------------------------------------------#
#Tick adults
#read in tick adult data
tick_adults_data <- read.csv("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/data/Deer_Tick_Surveillance__Adults__Oct_to_Dec__excluding_Powassan_virus__Beginning_2008.csv", head = T)
#create vector of counties in NY state in the dataset
counties <- unique(tick_adults_data$County)
counties <- na.omit(counties)
counties <- as.character(counties)
#set up vectors to collect results of stability time, absolute range, relative range
#run on adult deer tick data for each county with at least 10 years data
counties.with.10.years.data = c()
stability.time = c()
absolute.range.min.value = c()
absolute.range.max.value = c()
relative.range.min.value = c()
relative.range.max.value = c()
proportion.significant = c()
proportion.wrong = c()
for (i in counties) {
tryCatch({
#location: i
county <- tick_adults_data[tick_adults_data$County == i,]
#get only year and ticks found column
tick_adults <- county[,c("Year", "Tick.Population.Density")]
#omit nas
tick_adults <- na.omit(tick_adults)
#data now cleaned
#if number of years in location exceeds 9 run functions
if(nrow(tick_adults) >= 10) {
#i returns county name
print(i)
counties.with.10.years.data <- c(counties.with.10.years.data, i)
#iterates through our targetted windows and returns summary statistics
print("Multiple Breakups")
print(multiple_breakups(tick_adults))
#returns how many years it takes to reach stability
print("Stability Time")
st <- stability_time(tick_adults)
print(st)
stability.time <- c(stability.time, st)
#abs_range returns the absolute range of significant findings
print("Absolute Range")
ar <- abs_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(ar)
absolute.range.min.value <- c(absolute.range.min.value, ar[1])
absolute.range.max.value <- c(absolute.range.max.value, ar[2])
#relative_range returns the absolute over and under estimate compared to the slope of the longest series
print("Relative Range")
rr <- relative_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(rr)
relative.range.min.value <- c(relative.range.min.value, rr[1])
relative.range.max.value <- c(relative.range.max.value, rr[2])
#returns the proportion of total windows with statistically significant values
print("Proportion Significant")
ps <- proportion_significant(tick_adults, significance = 0.05)
print(ps)
proportion.significant <- c(proportion.significant, ps)
#proportion of significant relationships that does not match the direction of the true slope
print("Proportion Significantly Wrong")
psw <- proportion_wrong(tick_adults, significance = 0.05)
print(psw)
proportion.wrong <- c(proportion.wrong, psw)
#print pyramid plot to png
png(filename = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/Adult deer tick density in ", i, ", NY ",Sys.Date(),".png", sep = ''), width = 876, height = 604)
print(pyramid_plot(tick_adults, title=paste("Adult deer tick density in ", i, ", NY", sep = ''), plot_insig = TRUE, significance=0.05, rsq_points =TRUE, caption_plot = paste("Stability Time:", st)))
dev.off()
}
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
county_adult_tick_data_results <- data.frame(counties.with.10.years.data, stability.time, absolute.range.min.value, absolute.range.max.value, relative.range.min.value, relative.range.max.value, proportion.significant, proportion.wrong)
write.csv(county_adult_tick_data_results, file = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/ny_county_adult_tick_data_results_",Sys.Date(),".csv",sep = ""))
g <- c(0,0,4,1.4, 5.5)
g
g <- c(g, 0)
g
proportion.significant
proportion_wrong(test, significance=0.01)
proportion_wrong(test, significance=0.5)
proportion_wrong(test, significance=0.95)
proportion_wrong<- function(data, significance=0.05){#returns a single value between 0 and 1
test<-multiple_breakups(data)
count<-nrow(test)
true_slope<-test[count,4] #find the slope of the longest series
true_p<-test[count,6]
#case 1: true slope is not significant
if (true_p>significance){
wrong_windows<-test[which(test$p_value<significance),]
}else{ #true slope is significant
if(true_slope>0){#true slope is positive
wrong_windows<test[which(test$slope<0|test$p_value>significance),]#wrong means the slope is the wrong sign or 0
}else{#true slope is negative
wrong_windows<test[which(test$slope>0|test$p_value>significance),]#wrong means the slope is the wrong sign or 0
}
wrong_windows <- test
}
count_wrong<-nrow(wrong_windows)
proportion<-count_wrong/count
return(proportion)
}
proportion_wrong(test, significance=0.95)
proportion_wrong<- function(data, significance=0.05){#returns a single value between 0 and 1
test<-multiple_breakups(data)
count<-nrow(test)
true_slope<-test[count,4] #find the slope of the longest series
true_p<-test[count,6]
#case 1: true slope is not significant
if (true_p>significance){
wrong_windows<-test[which(test$p_value<significance),]
}else{ #true slope is significant
if(true_slope>0){#true slope is positive
wrong_windows<test[which(test$slope<0|test$p_value>significance),]#wrong means the slope is the wrong sign or 0
}else{#true slope is negative
wrong_windows<test[which(test$slope>0|test$p_value>significance),]#wrong means the slope is the wrong sign or 0
}
wrong_windows <- test
}
wrong_windows <- test
count_wrong<-nrow(wrong_windows)
proportion<-count_wrong/count
return(proportion)
}
proportion_wrong(test, significance=0.95)
proportion_wrong<- function(data, significance=0.05){#returns a single value between 0 and 1
test<-multiple_breakups(data)
count<-nrow(test)
true_slope<-test[count,4] #find the slope of the longest series
true_p<-test[count,6]
#case 1: true slope is not significant
if (true_p>significance){
wrong_windows<-test[which(test$p_value<significance),]
}else{ #true slope is significant
if(true_slope>0){#true slope is positive
wrong_windows<test[which(test$slope<0|test$p_value>significance),]#wrong means the slope is the wrong sign or 0
}else{#true slope is negative
wrong_windows<test[which(test$slope>0|test$p_value>significance),]#wrong means the slope is the wrong sign or 0
}
wrong_windows <- test
}
wrong_windows <- data
count_wrong<-nrow(wrong_windows)
proportion<-count_wrong/count
return(proportion)
}
proportion_wrong(test, significance=0.95)
proportion_wrong<- function(data, significance=0.05){#returns a single value between 0 and 1
test<-multiple_breakups(data)
count<-nrow(test)
true_slope<-test[count,4] #find the slope of the longest series
true_p<-test[count,6]
#case 1: true slope is not significant
if (true_p>significance){
wrong_windows<-test[which(test$p_value<significance),]
}else{ #true slope is significant
if(true_slope>0){#true slope is positive
wrong_windows<test[which(test$slope<0|test$p_value>significance),]#wrong means the slope is the wrong sign or 0
}else{#true slope is negative
wrong_windows<test[which(test$slope>0|test$p_value>significance),]#wrong means the slope is the wrong sign or 0
}
wrong_windows <- test
}
wrong_windows <- data
count_wrong<-nrow(data)
proportion<-count_wrong/count
return(proportion)
}
proportion_wrong(test, significance=0.95)
#read in tick adult data
tick_adults_data <- read.csv("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/data/Deer_Tick_Surveillance__Adults__Oct_to_Dec__excluding_Powassan_virus__Beginning_2008.csv", head = T)
#create vector of counties in NY state in the dataset
counties <- unique(tick_adults_data$County)
counties <- na.omit(counties)
counties <- as.character(counties)
#set up vectors to collect results of stability time, absolute range, relative range
#run on adult deer tick data for each county with at least 10 years data
counties.with.10.years.data = c()
stability.time = c()
absolute.range.min.value = c()
absolute.range.max.value = c()
relative.range.min.value = c()
relative.range.max.value = c()
proportion.significant = c()
proportion.wrong = c()
for (i in counties) {
tryCatch({
#location: i
county <- tick_adults_data[tick_adults_data$County == i,]
#get only year and ticks found column
tick_adults <- county[,c("Year", "Tick.Population.Density")]
#omit nas
tick_adults <- na.omit(tick_adults)
#data now cleaned
#if number of years in location exceeds 9 run functions
if(nrow(tick_adults) >= 10) {
#i returns county name
print(i)
counties.with.10.years.data <- c(counties.with.10.years.data, i)
#iterates through our targetted windows and returns summary statistics
print("Multiple Breakups")
print(multiple_breakups(tick_adults))
#returns how many years it takes to reach stability
print("Stability Time")
st <- stability_time(tick_adults)
print(st)
stability.time <- c(stability.time, st)
#abs_range returns the absolute range of significant findings
print("Absolute Range")
ar <- abs_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(ar)
absolute.range.min.value <- c(absolute.range.min.value, ar[1])
absolute.range.max.value <- c(absolute.range.max.value, ar[2])
#relative_range returns the absolute over and under estimate compared to the slope of the longest series
print("Relative Range")
rr <- relative_range(tick_adults, only_significant = FALSE, significance = 0.05)
print(rr)
relative.range.min.value <- c(relative.range.min.value, rr[1])
relative.range.max.value <- c(relative.range.max.value, rr[2])
#returns the proportion of total windows with statistically significant values
print("Proportion Significant")
ps <- proportion_significant(tick_adults, significance = 0.05)
print(ps)
proportion.significant <- c(proportion.significant, ps)
if(ps==0) {
proportion.significant <- c(proportion.significant, 0)
}
#proportion of significant relationships that does not match the direction of the true slope
print("Proportion Significantly Wrong")
psw <- proportion_wrong(tick_adults, significance = 0.05)
print(psw)
proportion.wrong <- c(proportion.wrong, psw)
#print pyramid plot to png
png(filename = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/Adult deer tick density in ", i, ", NY ",Sys.Date(),".png", sep = ''), width = 876, height = 604)
print(pyramid_plot(tick_adults, title=paste("Adult deer tick density in ", i, ", NY", sep = ''), plot_insig = TRUE, significance=0.05, rsq_points =TRUE, caption_plot = paste("Stability Time:", st)))
dev.off()
}
}, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
county_adult_tick_data_results <- data.frame(counties.with.10.years.data, stability.time, absolute.range.min.value, absolute.range.max.value, relative.range.min.value, relative.range.max.value, proportion.significant)#, proportion.wrong)
write.csv(county_adult_tick_data_results, file = paste("D:/Ixodes_scapularis_research_2019/bad_breakup_tick_algorithms/ny_county_adult_tick_data_results_",Sys.Date(),".csv",sep = ""))
